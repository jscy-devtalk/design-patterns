
# 프로토타입 패턴

## 정의
기존 인스턴스를 복제하여 새로운 인스턴스를 만드는 방법
 - 복제 기능을 갖추고 있는 기존 인스턴스를 프로토타입으로 사용해 새 인스턴스를 만들 수 있다.

## 주요 구성 요소
![img](https://github.com/zhtmr/static-files-for-posting/blob/main/static-files-for-posting/20240629/prototype-pattern.drawio.png?raw=true)

[//]: # (정리내용 ㄱㄱ)

## 객체를 복제할 때 생기는 문제점

<details>
<summary>객체 외부에서 private 필드를 복사할 수 없다.</summary>

> [!WARNING]
> ```java
> class Person {
>   private String name;
>   private int age;
>
>   public Person(String name, int age) {
>       this.name = name;
>       this.age = age;
>   }
>
>   // Getter
>   public String getName() {
>       return name;
>   }
>
>   public int getAge() {
>       return age;
>   }
> }
>
> public class Main {
>   public static void main(String[] args) {
>       Person person1 = new Person("Alice", 30);
>
>        // 비공개 필드 접근 시도 - 오류 발생
>        // String name = person1.name; // 컴파일 에러
>        // int age = person1.age; // 컴파일 에러
>
>        // 복제본을 생성하려고 하지만 비공개 필드에 접근할 수 없음
>        Person person2 = new Person(person1.getName(), person1.getAge());
>        
>        System.out.println(person1.getName() + ", " + person1.getAge());
>        System.out.println(person2.getName() + ", " + person2.getAge());
>    }
> }
>
> ```


</details>

<details>
<summary>객체의 복제본을 생성하려면 객체의 클래스를 알아야 한다.</summary>

클래스 의존도가 높아진다.

> [!WARNING]
> ```java
> class Employee {
>    private String name;
>    private int salary;
>
>    public Employee(String name, int salary) {
>        this.name = name;
>        this.salary = salary;
>    }
>
>    // Getter
>    public String getName() {
>        return name;
>    }
>
>    public int getSalary() {
>        return salary;
>    }
>
>    // 복사 생성자 필요
>    public Employee(Employee other) {
>        this.name = other.name;
>        this.salary = other.salary;
>    }
> }
>
> public class Main {
>   public static void main(String[] args) {
>       Employee emp1 = new Employee("Bob", 50000);
>
>       // 복제본을 생성하려면 Employee 클래스에 의존
>       Employee emp2 = new Employee(emp1); // Employee 클래스에 의존
>        
>       System.out.println(emp1.getName() + ", " + emp1.getSalary());
>       System.out.println(emp2.getName() + ", " + emp2.getSalary());
>   }
> }
>
> ```

</details>

<details>
<summary>인터페이스 기반 설계 문제</summary>

구체 클래스에 의존하지 않고 객체를 복제하기 어렵다.

> [!WARNING]
> ```java
> interface Copyable {
>     Copyable copy();
> }
>
> class Student implements Copyable {
>    private String name;
>    private int grade;
>
>    public Student(String name, int grade) {
>       this.name = name;
>       this.grade = grade;
>    }
>
>     @Override
>     public Copyable copy() {
>         return new Student(this.name, this.grade);
>     }
>
>     // Getter
>     public String getName() {
>         return name;
>     }
>
>     public int getGrade() {
>         return grade;
>     }
> }
>
> public class Main {
>   public static void main(String[] args) {
>       Copyable student1 = new Student("Charlie", 10);
>
>       // 인터페이스를 통해서는 구체적인 클래스에 접근할 수 없음
>       // Student student2 = (Student) student1.copy(); // 다운캐스팅 필요 - 유연성 저하
>         
>       Copyable student2 = student1.copy(); // Copyable 인터페이스로는 구체적인 필드 접근 불가
>         
>       // student2가 Student 타입인지 확인 후 캐스팅 필요
>       if (student2 instanceof Student) {
>           Student copiedStudent = (Student) student2;
>           System.out.println(copiedStudent.getName() + ", " + copiedStudent.getGrade());
>       }
>   }
> }
> ```

</details>

## 프로토타입 패턴 적용 하기 (java.lang.Cloneable 인터페이스 사용)
위 코드에서 `new GithubIssue(repository)` 부분을 중복으로 작성하지 않으려면 어떻게 해야할까?
예를들어 다음과 같이 간단하게 복제하고 싶다.

```java
githubIssue.clone(); // == new GithubIssue(repository);
```


[//]: # (clone != githubIssue ==> false 객체 레퍼런스는 다르다!)
[//]: # (clone.equals(githubIssue\) ==> true 내부 데이터는 같다!)

> [!NOTE]
> ddd

## 프로토타입 패턴 적용 하기 (커스텀 메소드 사용)

[//]: # (refactoring.guru 사이트 예제가 더 좋다!!)

## 장점과 단점

## 자바에서 찾아보는 프로토타입

## 스프링에서 찾아보는 프로토타입

> [!NOTE] 객체를 복제하는 다양한 방법
> ### 복사 생성자
> 클래스 내부에 `복사 생성자`를 정의하여, 해당 클래스의 인스턴스를 매개변수로 받아 필드 값을 복사한다.
> 
> ```java
> class Person {
>   private String name;
>   private int age;
>
> // 생성자
> public Person(String name, int age) {
>   this.name = name;
>   this.age = age;
> }
>
> // 복사 생성자
> public Person(Person other) {
>   this.name = other.name;
>   this.age = other.age;
> }
>
> //  // Getter 가 없어도 private 필드 복사 가능
> //  public String getName() {
> //    return name;
> //  }
> //
> //  public int getAge() {
> //    return age;
> //  }
>
> 
> @Override
> public String toString() {
>   return "Person{name='" + name + "', age=" + age + "}";
> }
> }
>
> public class Main {
>   public static void main(String[] args) {
>       Person person1 = new Person("Alice", 30);
>       Person person2 = new Person(person1); // 복사 생성자 사용
>
>     System.out.println(person1);
>     System.out.println(person2);
>   }
> }
>
> ```
> ### 직렬화
> 객체를 직렬화한 후 역직렬화하는 방법. 이 방법은 깊은 복사를 보장한다.
> 
> ```java
> import java.io.*;
>
> public class MyClass implements Serializable {
>     private int field1;
>     private String field2;
>     
>     public MyClass deepCopy() {
>         try {
>             ByteArrayOutputStream bos = new ByteArrayOutputStream();
>             ObjectOutputStream out = new ObjectOutputStream(bos);
>             out.writeObject(this);
>             
>             ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray());
>             ObjectInputStream in = new ObjectInputStream(bis);
>             return (MyClass) in.readObject();
>         } catch (IOException | ClassNotFoundException e) {
>             e.printStackTrace();
>             return null;
>         }
>     }
>     
>     // 기타 메서드 및 접근자
> }
>
> ```
>
> 자바스크립트에서는 `JSON.stringify()` 와 `JSON.parse()` 를 통해 가능하다.
> ```javascript
> const obj = {
>   a: 1,
>   b: {
>     c: 2,
>   },
> };
>
> const copiedObj = JSON.parse(JSON.stringify(obj));
>
> copiedObj.b.c = 3
>
> obj.b.c === copiedObj.b.c  //false 
> ```
> 
> ### 팩토리 메소드
> 클래스의 의존성을 줄일 수 있다.
> 
> ```java
> public interface Copyable {
>     Copyable copy();
> }
>
>
> public class MyClass implements Copyable {
>     private int field1;
>     private String field2;
>     
>     @Override
>     public MyClass copy() {
>         return new MyClass(this);
>     }
>     
>     // 복사 생성자
>     public MyClass(MyClass other) {
>         this.field1 = other.field1;
>         this.field2 = other.field2;
>     }
>     
>     // 기타 메서드 및 접근자
> }
>
> ```



