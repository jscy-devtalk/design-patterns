
# 프로토타입 패턴

## 정의
기존 인스턴스를 복제하여 새로운 인스턴스를 만드는 방법
 - 복제 기능을 갖추고 있는 기존 인스턴스를 프로토타입으로 사용해 새 인스턴스를 만들 수 있다.

## 주요 구성 요소
![img](https://github.com/zhtmr/static-files-for-posting/blob/main/static-files-for-posting/20240629/prototype-pattern.drawio.png?raw=true)

[//]: # (정리내용 ㄱㄱ)

## 프로토타입 패턴 적용 전
Github api 를 사용하여 이슈를 만드는 아래와 같은 코드가 있다고 가정해보자. 
만약 새로운 Github issue 를 발행하려면 새로운 `GithubIssue` 객체를 만들어 값을 세팅하면 된다.

새로운 이슈를 만들때마다 계속해서 반복적인 코드를 작성해야 한다.

```java
public static void main(String[] args) {
    GithubRepository repository = new GithubRepository();
    repository.setUser("zhtmr");
    repository.setName("doc-prototype");

    // 1번 git issue
    GithubIssue githubIssue = new GithubIssue(repository);
    githubIssue.setId(1);
    githubIssue.setTitle("프로토타입 정리");

    // 2번 git issue
    GithubIssue githubIssue2 = new GithubIssue(repository);
    githubIssue.setId(2);
    githubIssue.setTitle("싱글톤패턴 정리");
    
    // 3번 git issue
    // 4번 git issue
    // ...
    
    String url = githubIssue.getUrl();
    System.out.println(url);
}
```

## 프로토타입 패턴 적용 하기 (java.lang.Cloneable 인터페이스 사용)
위 코드에서 `new GithubIssue(repository)` 부분을 중복으로 작성하지 않으려면 어떻게 해야할까?
예를들어 다음과 같이 간단하게 복제하고 싶다.

```java
githubIssue.clone(); // == new GithubIssue(repository);
```


[//]: # (clone != githubIssue ==> false 객체 레퍼런스는 다르다!)
[//]: # (clone.equals(githubIssue\) ==> true 내부 데이터는 같다!)

> [!NOTE]
> ddd

## 프로토타입 패턴 적용 하기 (커스텀 메소드 사용)


## 장점과 단점

## 자바에서 찾아보는 프로토타입

## 스프링에서 찾아보는 프로토타입

> [!NOTE] 객체를 복제하는 다양한 방법
> ### 복사 생성자
> 클래스 내부에 복사 생성자를 정의하여, 해당 클래스의 인스턴스를 매개변수로 받아 필드 값을 복사한다.
> ```java
> public class MyClass {
>     private int field1;
>     private String field2;
>
>     // 복사 생성자
>     public MyClass(MyClass other) {
>         this.field1 = other.field1;
>         this.field2 = other.field2;
>     }
>     
>     // 기타 메서드 및 접근자
> }
>
> ```
> ### 직렬화
> 객체를 직렬화한 후 역직렬화하는 방법. 이 방법은 깊은 복사를 보장한다.
> ```java
> import java.io.*;
>
> public class MyClass implements Serializable {
>     private int field1;
>     private String field2;
>     
>     public MyClass deepCopy() {
>         try {
>             ByteArrayOutputStream bos = new ByteArrayOutputStream();
>             ObjectOutputStream out = new ObjectOutputStream(bos);
>             out.writeObject(this);
>             
>             ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray());
>             ObjectInputStream in = new ObjectInputStream(bis);
>             return (MyClass) in.readObject();
>         } catch (IOException | ClassNotFoundException e) {
>             e.printStackTrace();
>             return null;
>         }
>     }
>     
>     // 기타 메서드 및 접근자
> }
>
> ```
>
> ### 팩토리 메소드
> 클래스의 의존성을 줄일 수 있다.
> ```java
> public interface Copyable {
>     Copyable copy();
> }
>
>
> public class MyClass implements Copyable {
>     private int field1;
>     private String field2;
>     
>     @Override
>     public MyClass copy() {
>         return new MyClass(this);
>     }
>     
>     // 복사 생성자
>     public MyClass(MyClass other) {
>         this.field1 = other.field1;
>         this.field2 = other.field2;
>     }
>     
>     // 기타 메서드 및 접근자
> }
>
> ```
>
> 자바스크립트에서는 `JSON.stringify()` 와 `JSON.parse()` 를 통해 가능하다.
> ```javascript
> const obj = {
>   a: 1,
>   b: {
>     c: 2,
>   },
> };
>
> const copiedObj = JSON.parse(JSON.stringify(obj));
>
> copiedObj.b.c = 3
>
> obj.b.c === copiedObj.b.c  //false 
> ```


