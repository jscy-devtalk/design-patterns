# 어댑터 패턴
![](https://github.com/zhtmr/static-files-for-posting/blob/main/static-files-for-posting/20240624/%EC%96%B4%EB%8C%91%ED%84%B0%ED%8C%A8%ED%84%B4_%EC%82%AC%EC%A7%841.png?raw=true)
*출처: https://refactoring.guru/ko/design-patterns/adapter*

## 정의
기존 코드를 클라이언트가 사용하는 인터페이스의 구현체로 바꿔주는 패턴
- 클라이언트가 사용하는 인터페이스를 따르지 않는 기존 코드를 재사용할 수 있게 해준다.

## 주요 구성 요소
![](https://github.com/zhtmr/static-files-for-posting/blob/main/static-files-for-posting/20240624/adapter-pattern.drawio.png?raw=true)

클라이언트는 `Target` 인터페이스에만 의존한다. 그리고 기존에 사용하던 코드(`Adaptee`)와 `Target` 사이에 `Adapter`라는 구현체가 있다. 여기서 `Adapter` 의 역할은 기존에 사용하던 코드를 클라이언트가 의존하는 타입의 객체로 **변환시켜 주는 역할**을 한다.

## 어댑터 패턴 적용 전
![img.png](https://github.com/zhtmr/static-files-for-posting/blob/main/static-files-for-posting/20240624/%ED%8C%A8%ED%82%A4%EC%A7%80%EA%B5%AC%EC%A1%B0.png?raw=true)   
*어댑터 패턴 적용 전 패키지 구조*


<details>
<summary>코드보기</summary>

## LoginHandler
```java
public class LoginHandler {

    UserDetailsService userDetailsService;

    public LoginHandler(UserDetailsService userDetailsService) {
        this.userDetailsService = userDetailsService;
    }

    public String login(String username, String password) {
        UserDetails userDetails = userDetailsService.loadUser(username);
        if (userDetails.getPassword().equals(password)) {
            return userDetails.getUsername();
        } else {
            throw new IllegalArgumentException();
        }
    }
}
```

## UserDetails
```java
public interface UserDetails {

    String getUsername();

    String getPassword();

}

```

## UserDetailsService
```java
public interface UserDetailsService {

    UserDetails loadUser(String username);

}
```

## Account
```java
public class Account {

    private String name;

    private String password;

    private String email;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }

    public String getEmail() {
        return email;
    }

    public void setEmail(String email) {
        this.email = email;
    }

}
```

## AccountService
```java
public class AccountService {

    public Account findAccountByUsername(String username) {
        Account account = new Account();
        account.setName(username);
        account.setPassword(username);
        account.setEmail(username);
        return account;
    }

    public void createNewAccount(Account account) {

    }

    public void updateAccount(Account account) {

    }

}

```

</details>

코드를 간략하게 살펴보면, `UserDetails` 인터페이스는 유저의 이름과 비밀번호를 가져오는 기능을 하고, `UserDetailsService` 는 유저의 이름을 받아 그 유저 정보를 반환하는 역할을 하고있다.

기존에는 `AccountService` 를 통해 유저 정보를 가져왔는데, 앱을 개선하는 과정에서 새로운 방식으로(`LoginHandler`) 호출해야 하는 상황에 놓인 것이다.

예를 들어 security 패키지(외부 라이브러리라고 가정)를 우리 프로젝트에 통합하여 쓰고자 한다.  
이제부터 클라이언트는 `UserDetailService` 를 통해 데이터를 가져와야 한다고 하면 기존의 코드를 변경하지 않고 어떻게 새로운 방식과 통합할 수 있을까?

그러기 위해 먼저 서로 호환되지 않는 `AccountService` 와 `UserDetailsService` 를 연결해야 하고, `Account` 와 `UserDetails` 를 연결해야 한다.


## 어댑터 패턴 적용 하기

기존의 코드(Adaptee) 를 Target 타입에 맞게 변형해주는 클래스(Adpater)를 정의해야 한다.

Adapter 클래스는 Adaptee 를 포함하도록 만든다.

<details>
<summary>코드보기</summary>

## AccountUserDetailsService
`UserDetails` 구현체에서 기존에 쓰던 `AccountService` 객체를 사용하도록 한다.
이 객체는 기존 서비스의 반환값을 Target 인터페이스 규격에 맞춰 반환 하는 역할을 한다.

```java
public class AccountUserDetailsService implements UserDetailsService {

    private AccountService accountService;

    public AccountUserDetailsService(AccountService accountService) {
        this.accountService = accountService;
    }

    @Override
    public UserDetails loadUser(String username) {
        return new AccountUserDetails(accountService.findAccountByUsername(username));
    }
}
```

## AccountUserDetails

```java
public class AccountUserDetails implements UserDetails {

    private Account account;

    public AccountUserDetails(Account account) {
        this.account = account;
    }

    @Override
    public String getUsername() {
        return account.getName();
    }

    @Override
    public String getPassword() {
        return account.getPassword();
    }
}
```

## Client
 
```java
public class App {

    public static void main(String[] args) {
        AccountService accountService = new AccountService();
        UserDetailsService userDetailsService = new AccountUserDetailsService(accountService);
        LoginHandler loginHandler = new LoginHandler(userDetailsService);
        String login = loginHandler.login("keesun", "keesun");
        System.out.println(login);
    }
}
```

</details>

결과적으로 Adaptee 를 호출해 나온 결과를 클라이언트가 원하는 타입인 Target 타입으로 바꿔주는 역할을 하는것이 Adapter 다.

## 장점과 단점
- 장점
  - 기존 코드를 변경하지 않고 원하는 인터페이스 구현체를 만들어 재사용 가능. (OCP)
  - 기존 코드가 하던 일과 특정 인터페이스 구현체로 변환하는 작업을 각기 다른 클래스로 분리하여 관리할 수 있다. (SRP)

- 단점
  - 새 클래스가 생겨 복잡도가 증가할 수 있다. 

## 자바에서 찾아보는 어댑터 패턴

## 스프링에서 찾아보는 어댑터 패턴 
